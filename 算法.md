# Interview-Question
iOS 面试题积累 - 算法篇

1. 递归计算1到100的和	

```swift
func makeSum(_ num: NSInteger) -> NSInteger {
    
    if num > 0 {
        
        i = i + 1
        return makeSum(num - 1) + num
        
    }
    return 0
}

makeSum(100)
```

2. 设计一个递归搜索制定目录下指定类型文件到函数，要求写清返回值、函数名、参数列表。*只写函数名，不用写函数内容。

伪函数：

```
func isSomeFile(filePath: String) -> BOOL {} // 判断是否是某种类型文件
func isDirectory(filePath: String) -> BOOL {} // 判断是否是文件夹
func findSomeFile(filePath: String) {
    if isDirectory(filePath) { // 如果是文件夹路径
        for subPath in filePath.subPath {
            findSomeFile(subPath) // 递归调用
        }
    }else { 
        // 不是文件夹路径，则打印出文件路径
        if isSomeFile(filePath) {
            print(filePath)
        }
    }
}
```

swift 实现：

```swift
func isSomeFile(_ fileName: String) -> Bool {
    
    return true
}

func findSomeFile(_ filePath: String) {
    
    let manager = FileManager.default
    var isDir = ObjCBool(false)
    let isExist = manager.fileExists(atPath: filePath, isDirectory: &isDir)
    
    if isExist {
        if isDir.boolValue {
            
            guard let dirArray = try?  manager.contentsOfDirectory(atPath: filePath) else { return }
            var subPath: URL
            for str in dirArray {
                subPath = URL(fileURLWithPath: filePath).appendingPathComponent(str)
                var isSubDir = ObjCBool(false)
                manager.fileExists(atPath: subPath.absoluteString, isDirectory: &isSubDir)
                findSomeFile(subPath.absoluteString)
            }
        }else {
            
            let fileName = URL(fileURLWithPath: filePath).lastPathComponent
            if isSomeFile(fileName) {
                print(fileName)
            }
        }
    }
}
```



3. n个数不相等，求其中的max、min，考虑比较次数，最优的比较次数是多少？

分治处理：

同时找到最大值和最小值的话，一般方法（遍历两遍）是O（2n），改进方法是每次读两个数，这两个数比一次，然后大的和当前最大值比，小的和当前最小值比。这样每两个数比了三次，故复杂度是O（3/2n），不过两种方法都是O（n）。算法导论里面有介绍。

参考： https://www.zhihu.com/question/28892158

4. 利用rand7（可以产生1-7的随机数），求rand13（要求是均等）

分析：

要保证`rand13()`在整数`1-13`的均匀分布，可以构造一个`1-13*n`的均匀分布的随机整数区间（n为任何正整数）。假设x是这个`1-13*n`区间上的一个随机整数，那么`x%13+1`就是均匀分布在`1-13`区间上的整数。由于`(rand7()-1)*7+rand7()`可以构造出均匀分布在`1-49`的随机数（原因见下面的说明），可以将40～49这样的随机数剔除掉，得到的数1-39仍然是均匀分布在1-39的，这是因为每个数都可以看成一个独立事件。

下面说明为什么`(rand7()-1)*7+rand7()`可以构造出均匀分布在1-49的随机数:

首先`rand7()-1`得到一个离散整数集合`{0，1，2，3，4，5，6}`，其中每个整数的出现概率都是1/7。那么`(rand7()-1)*7`得到一个离散整数集合`A={0，7，14，21，28，35，42}`，其中每个整数的出现概率也都是1/7。而`rand7()`得到的集合`B={1，2，3，4，5，6，7}`中每个整数出现的概率也是1/7。显然集合A和B中任何两个元素组合可以与1-49之间的一个整数一一对应，也就是说1-49之间的任何一个数，可以唯一确定A和B中两个元素的一种组合方式，反过来也成立。由于A和B中元素可以看成是独立事件，根据独立事件的概率公式`P(AB)=P(A)P(B)`，得到每个组合的概率是`1/7*1/7=1/49`。因此`(rand7()-1)*7+rand7()`生成的整数均匀分布在1-49之间，每个数的概率都是1/49。

参考：https://blog.csdn.net/ljsspace/article/details/6820753

代码参考：swift

```swift
func rand7() -> NSInteger {
    
    return NSInteger(arc4random() % 7) + 1
}

func rand13() -> NSInteger {
    
    var x = 0
    
    repeat {
        x = (rand7() + 1) * 7 + rand7()
    }while x > 39;
    
    return x % 13 + 1;
}
```





